# 데이터 모델링의 이해 

# 1절 데이터 모델의 이해

## 1. 모델링
- 복잡한 현실세계 -> 추상화, 단순화하여 일정한 표기법(형식)에 의해 명시적으로 표현하는 것.
- 데이터베이스를 구축하기 위한 분석, 설계의 과정
- 정보 시스템을 구축하기 위한 데이터 관점의 업무 분석 기법

## 2. 모델링의 특징(구체화, 복잡화, 일반화 X, 정화함 O)
- 추상화(모형화): 현실세계를 일정한 형식에 맞춰 간략히 표현
- 단순화: 약속된 규약으로 제한된 표기법이나 언어로 표현 
- 명확화: 애매모호함을 제거하고 정확하게 현상을 기술하는 것 
- 목적: 업무정보를 구성하는 기초 정보들을 일정한 표기법으로 표현하여 정보시스템 구축의 대상이 되는 업무 내용르 정확하게 분석하는 것

## 3. 모델링의 관점
- What = 데이터의 관점: 무엇이 필요한지에 관심 업무와 데이터의 관계, 데이터와 데이터의 관계를 모델링, 프로세스에서 사용하는 데이터를 모델링
- How = 프로세스의 관점: 어떤, 절차/순서로 이루어지는지에 대한 관심
 업무가 실제로 하고있는 일, 해야하는 일을 모델링 
 - Interaction = 데이터와 프로세스의 상관 관점: 업무 처리 방법에 따라 데이터가 받는 영향을 모델링 

 ## 4. 데이터 모델링의 중요성과 주의점
 - 중요성: 파급효과, 간결한 표현, 데이터 품질 유지
 - 유의점:
    - 중복: 여러 db에 같은 정보를 저장하지 않도록 설계해야함
    - 비유연성: 데이터의 정의를 데이터의 사용 프로세스와 분리해야함. 사소한 업무 변화에 데이터 모델이 수시로 변경되면 안됨. 
    - 비일관성: 데이터 간 상호 연관 관계가 명확히 정의되어야함.

## 5. 데이터 모델링의 3단계 
- 개념적 모델링: 업무중심적, 포괄적인 수준의 모델링, 추상화 수준이 가장 높믐, 업무 분석 후 업무의 핵심 Entity를 추출, ERD 도출
- 논리적 모델링: 테이블 구축(key, 속성, 관계) 표현, 정규화 적용 -> 데이터의 일관성 적용
- 물리적 모델링: 데이터 인덱스, 저장 방식 등 물리적인 성격 고려

## 6. 데이터의 독립성
- 데이터의 구조에  변화가 생겨도 응용 프로그램이 변경될 필요 X
- 특정 스키마를 변경해도 상위 수준의 스키마 정의에 영향 X
- 논리적, 물리적 독립성의 보장으로 실현됨

만약 데이터의 독립성이 보장되지 않는다면? 
- 데이터의 중복성 및 복잡도 증가
- 요구사항 대응 난이도 증가 -> 데이터 유지보수 비용 증가 

## 7. 데이터베이스 스키마
- 데이터 베이스 모델링의 대상
- 데이터베이스 구조, 데이터 타입, 제약조건에 대한 명세
- 데이터베이스 설계 단계에서 명시되며 자주 변경되지 않음 

## 8. 데이터베이스 3단계 구조 
![alt text](../../images/image.png)
- 외부 스키마: 사용자 개개인의 관점, View(여러 사용자의 관점), DB 이용자의 관점으로 구성된 개인적 DB 스키마
- 개념 스키마: 모든 사용자의 관점을 통합, 조직 전체 관점의 통합, db에 저장되는 그들의 관계 설계자의 관저 
- 내부 스키마: db가 물리적으로 저장된 형식, 개발자 관점, 데이터가 어떻게 저장되는가, 저장 장치 관점

데이터 모델링은 통합 관점의 개념 스키마를 만들어가는 과정

## 9. 사상 
- 논리적 독립성: 외부 스키마와 개념 스키마의 맵핑을 통해 보장
    - 개념 스키마가 변경되어도 외부 스키마에 영향 X
    - 논리적 구조가 변경되어도 응용 프로그램에 영향 X
- 물리적 독립성: 개념 스키마와 내붑 스키마의 매핑을 통해 보장 
    - 내부 스키마가 벼경되어도 외부/개념 스키마에 영향 X
    - 저장장치의 구조변경은 응용프로그램과 개념 스키마에 영향 X
    - 물리 스키마가 변경되어도 논리 스키마에 영향 X

## 10. 데이터 모델링의 3가지 요소
- Entity: 업무와 관련된 어떤 것(things)
    ex) 학생, 과목
- Attribute: 어떤 것이 갖는 성격
    ex) 이름, 학점, 과목명
- Relationship: 어떤 것의 관계 
    ex) 수강하다

- 데이터베이스 인스턴스
특정 시점에 db에 실제로 저장되어 있는 데이터 값 

## 11. 좋은 데이터 모델의 요소 
- 완전성: 업무에서 필요로 하는 모든 데이터가 모델에 정의되어야 함
- 중복 배제: 하나의 db 내에 동일한 사실은 1번만 기록되어야함
- 업무규칙: 업무 규칙이 데이터 모델에 표현되어야 하고, 모든 사용자가 공유할 수 있도록 제공되야함.
- 데이터 재사용: 회사 전체 관점에서 공통 데이터를 도출하고 이를 전 영역에서 사용할 수 있도록 설계해야함

- 의사소통: 업무 규칙은 엔티티, 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현되어야함.
- 통합성: 동일한 데이터는 조직의 전체에서 1번만 정의되고, 이를 다른 영역에서 참조, 활용해야함.

## 12. 데이터 모델링의 이해 관계자 
![alt text](../../images/image-1.png)

## 13. ERD
- 업무 분석에서 도출된 엔티티와 엔티티의 관계를 이해하기 쉽게 도식화한 다이어그램
- 데이터 흐름과 프로세스와의 연관성을 이야기하는 표기법이자 산출물 

## 14. ERD 작성 순서
1. 엔티티를 그린다
2. 엔티티 배치 (가장 중요한 엔티티는 왼쪽 상단에 배치)
3. 엔티티 관계 설정
    - 식별자를 우선 설정 
    - 가급적 사이클 관계가 발생되지 않도ㅗㄱ 한다.
4. 관계명을 기술한다.
5. 관계의 참여도를 기술한다.
6. 관계의 필수/선택 여부를 기술한다. 필수여부는 원을 이용하여 표시 

## 15. ERD 표기법
![alt text](../../images/image-2.png)

# 2절 엔티티

## 1. 엔티티란? 
- 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합 
- 엔티티 = 인스턴스의 집합 

## 2. 엔티티 유형 
- 유형, 무형에 따른 분류
    - 유형 엔티티
        물리적인 형태가 있고 안정적이며 지속적인 활용
        ex) 교수, 강의실, 물품, 사원
    - 무형 엔티티
        물리적인 형태는 존재하지 않으니 관리해야 할 개념적 정보
        ex) 수업, 보험상품, 시스템, 조직
    - 사건 엔티티 
        업무 수행 과정에서 발생, 비교적 발생량이 많음
        ex) 수강신청, 주문, 입금, 미납
        혼자 존재할 수 없는 엔티티, 다른 엔티티에 의존해있음
- 발생 시점에 따른 분류 
    - 기본 엔티티
        - 업무에 본래 존재하는 정보, 독립적으로 생성되는 엔티티 
        - 타 엔티티의 부모 역할, 자신의 고유 주식별자를 가짐
        ex) 사원, 부서, 고객, 상품, 자재
    - 중심 엔티티
        - 기본 엔티티로부터 발생, 기본 엔티티와 행위 엔티티 중간에 존재
        - 다른 엔티티와의 관계를 통해 많은 행위 엔티티 생성 
        ex) 계약, 주문, 청구, 사고, 매출
    - 행위 엔티티
        - 2개 이상의 부모 엔티티로부터 발생
        - 업무처리를 하는 동안 발생되는 엔티티
        - 자주 변경되고 지속적으로 정보가 추가되어 데이터양이 많음
## 3. 엔티티의 특징 
- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이다.
- 유일한 식별자에 의해 식별이 가능하다.
- 영속적으로 존재하는 인스턴스의 집합이다.
- 업무 프로세스에 이용된다.
- 업무 프로세스 CRUD가 발생하는 엔티티이어야한다.
- 반드시 속성을 가진다
- 다른 엔티티와 최소 1개 이상의 관계가 있다.
- 시스템 처리시 내부 필요에 의한 엔티티를 고립 엔티티라고 하기도 함

## 4. 엔티티의 명명
- 약어 X
- 단수 명사
- 유일한 이름

# 3절 속성

## 1. 속성의 정의
- 사물의 성질 또는 본질
- 업무에서 필요로하는 인스턴스에서 관리하고자 하는 의미상 더이상 분리되지 않는 최소의 데이터 단위 
- 1개의 엔티티는 2개 이상의 인스턴스 집합이어야 한다.
- 1개의 엔티티는 2개 이상의 속성을 가진다.
- 1개의 속성은 1개의 속상값을 가진다.

## 2. 속성의 특징
- 해당 업무에서 필요하고 관리해야 하는 정보
- 정규화 이론에 근간하여 주식별자에 함수적으로 종속되어야 함.
- 하나의 속성은 한 개의 값만을 가져야함

## 3. 속성의 명명
- 해당 업무에서 사용하는 이름을 부여
- 약어 사용은 가급적 지양
- 서술식 속성명은 피하고 명사형 속성명을 사용
- 수식어, 소유격을 피한다.
- 속성의 이름은 전체 데이터 모델에서 유일성을 확보 

## 4. 속성의 표기법
![alt text](../../images/image-3.png)

## 5. 속성의 도메인 
- 각 속성이 가질 수 있는 값의 범위 
- 속성에 대한 데이터 타입과 크기, 그리고 제약사항을 지정

## 6. 속성에 따른 분류
- 특성에 따른 분류
    - 기본 속성
        - 업무로 부터 추출한 모든 속성, 가장 일반적인 속성 
        - ex) 회원 ID, 이름, 계좌번호, 주문일자, 현금
    - 설계 속성
        - 업무상 필요한 데이터 이외에 데이터 모델링을 위해 만든 속성
        - 업무를 규칙화하기 위해 새로 만들거나 변형, 정의하는 속성 
        - ex) 일련번호, 주문 번호, 상품코드 
    - 파생 속성
        - 다른 속성들롭터 유도된 속성
        - 다른 속성에 영향을 받아 발생하는 속성
        - 보통 계산된 값들이 해당(통계)
        - 데이터를 조회할 때 성능을 빠르게 하게 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성 
        - 관련 값들이 업데이트될 경우 관리 부담 -> 가급적 적게 정의
        - ex) 합계, 평균, 전체 수

- 엔티티 구성방식에 따른 분류 
    - 기본 키 속성(PK): 엔티티의 인스턴스를 구별할 수 있는 속성 
    - 외래 키 속성(FK): 다른 엔티티와 관계에서 포함된 속성
    - 일반 속성: PK, FK에 포함되지 않는 속성
- 속성값 수에 따른 분류
    - 단일값 속성: 하나의 값만 가지는 속성
    - 다중값 속성: 여러 개의 값을 가지는 속성
- 분리 가능성에 따른 분류 
    - 단순 속성: 다른 속성으로 구성할 수 없는 속성 
    - 복합 속성: 여러 속성들로 구성된 속성 

# 4절 관계
## 1. 관계의 정의
- 엔티티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태

## 2. 관계의 페어링 
- 페어링: 엔티티 안의 인스턴스가 개별적으로 관계를 가지는 것
- 관계: 페어링의 집합을 논리적으로 표현한 것

## 3. 관계의 분류
![alt text](../../images/image-4.png)

1. 존재에 의한 관계
    - 하나의 엔티티가 다른 엔티티에 항상 속해 있다.
    - 각 엔티티는 독립적으로 존재할 수 있다.
    - UML에 연관관계라고 표현한다 (실선)
    - 연관관계는 소스코드에서 멤버변수로 선언하여 사용할 수 있다.
2. 행위에 의한 관계
    - 혼자서는 존재할 수 없는 엔티티(사건 엔티티)
    - UML에서는 의존관계라고 표현한다(점선으로 표기)
    - 의존관계에서는 오퍼레이션에서 파라미터 등으로 이용할 수 있다.

## 4. 관계의 표기법
- 관계명: 관계의 이름(애매한 동사 지양, 현재형으로 표현)
- 관계 차수: 각 관계에 참여할 수 있는 인스턴스 수 
- 관계 선택사양(선택성): 필수참여관계(|), 선택참여관계(O)

## 5. 관계 체크사항
1. 2개의 엔티티 사이에 관심있는 연관 규칙이 존재하는가
2. 2개의 엔티티 사이에 정보의 조합이 발생하는가
3. 업무 기술서, 장표에 관계 연결을 가능하게 하는 동사가 있는가

## 6. 관계 읽기 
![alt text](../../images/image-5.png)

# 5절 식별자 
## 1. 식별자 개념
- 하나의 엔티티에 구성되어 있는 여러 개의 속성 중 엔티티를 대표할 수 있는 속성, 각각의 인스턴스를 구분 가능하게 해주는 대표 속성 
- 하나의 엔티티는 반드시 하나의 유일한 식별자가 존재한다.

## 2. 식별자 특징
- 유일성
    주식별자에 의해 엔티티 내의 모든 인스턴스를 유일하게 구분
- 최소성
    주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야함.
- 불변성
    주식별자가 한번 특정 엔티티에 지정되면 그 식별자 값은 변하면 안됨
- 존재성
    주식별자가 지정되면 반드시 데이터의 값이 존재해야한다.(NOT NULL)

## 3. 식별자의 분류

![alt text](../../images/image-6.png)

### 키의 종류
1. 후보키
    - 테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합
    - 유일성과 최소성을 동시에 만족해야함
2. 기본키
    - 후보키 중 엔티티를 대표하는 키로 선정된 키
3. 슈퍼키
    - 유일성은 만족하나 최소성은 만족하지 못함
4. 대체키
    - 후보키 중 선별된 기본키를 제외하고 남은 키

- 주 식별자 도출 기준
    - 해당 업무에서 자주 이용되는 속성, 자주 변하지 않는 값
    - 명칭, 내역 등과 같이 이름으로 기숭되는 것들은 가능하면 지정X
    - 복합으로 주식별자로 구성할 경우, 너무 많은 속성은 포함 X

## 4. 식별자와 비 식별자의 관계
- 식별자 관계 
    - 자식의 PK가 부모의 PK를 포함시켜서 복합키로 사용하는 경우
    - SQL 조인 관계를 최소화해야함
- 비 식별자 관계
    - 자식의 PK는 따로 두고 부모 PK는 자식의 FK를 단순 참조하는 경우
    - 부모의 주식별자가 자식 엔티티의 비식별자 속성으로 상속
    - 부모 엔티티 없이 자식 엔티티가 생성이 가능한 경우
    - PK 속성의 단순화가 필요한 경우
    - SQL 복잡도 상승 예방

![alt text](../../images/image-7.png)

# 데이터 모델링의 이해 (2)

# 1절 정규화
- 삭제 이상
어떤 정보를 삭제하면서 원하지 않게 다른 정보도 삭제

- 삽입 이상
관련 없는 정보가 비어 있어 원하는 정보 입력 불가

- 갱신 이상
정보를 갱신할 때 다른 정보도 업데이트를 해주어야한다.

이를 해결하기 위해 큰 주제별로 독립된 테이블로 만들어주는 과정을 정규화 라고한다.

### 1. 정규화
- 정규화는 최소한의 데이터 중복, 최대한의 데이터 유연성, 데이터의 일관성을 위해 데이터를 분리하는 과정이다.
- 데이터의 중복을 제거, 독립성을 확보한다.
- 정규화를 통해 데이터 모델의 벼경을 최소화 할 수 있다.
- 논리 데이터 모델 상세화 과정의 대표적인 활동 

> 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력, 수정, 삭제 이상을 제거하는 것

### 2. 정규화 종류
- 정규형: 정규화로 도출된 데이터 모델이 갖춰야할 특성
1. 제 1 정규형 (1NF) 원자성, 완전 함수 종속성 제거
모든 속성은 반드시 하나의 값을 가져야 한다.

2. 제 2 정규형 (2NF) 부분함수종속성 제거
엔티티의 일반 속성은 주식별자 전체에 종속이어야 한다.

3. 제 3 정규형 (3NF) 이행함수종속성 제거
엔티티의 일반속성 간에는 서로 종속적이지 않다.

> 이전 단계의 정규형을 만족해야 그 다음 단계의 정규화를 진행할 수 있다.

### 3. 함수적 종속성(FD)
- 부분함수종속: 하나의 PK가 혼자서 속성을 결정하는 것
- 이행함수종속: PK가 아닌 값이 속성을 결정하는 것 

식별자가 아닌 속성이결정자 역할을 하는 함수 종속을 제거하면 제 3 정규형을 얻을 수 있다.

![alt text](../../images/image-8.png)

### 4. 정규화의 성능
- 데이터의 중복 감소 -> 성능 향상
- 데이터의 관심사 분리 -> 성능 향상
- 데이터 입력/수정/삭제 -> 성능 향상
- 조회 쿼리에서 JOIN 많이 발생 -> 성능 저하

#### BCNF
- 제 3 정규형을 만족하면서 모든 결정자가 후보 키 집합에 속해야한다.
- 즉, 후보 키 집합에 속하지 않은 컬럼이 결정자가 되어서는 안된다.

#### 제 4 정규형(4NF)
- BCNF를 만족하며 다치 종속이 없어야한다.
> 다치종속: A -> B일 떄, 하나의 a값에 여러 개의 B값이 존재.

#### 제 5 정규형(5NF)
- 4NF를 만족해야 하며 조인 종속이 없어야 한다.
- 조인 연산을 했을 때 손실이 없어야 한다.


# 2절 관계와 조인의 이해

### 1. 관계
- 엔티티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태
- 부모의 식별자를 자식의 식별자에 포함하면 식별관계, 부모의 식별자를 자식의 일반속성으로 상속하면 비식별관계
- 관계를 맺는다 = 식별자를 상속시키고 해당 식별자를 매핑 키로 활용해 데이터를 결합하겠다는 것.
### 2. 관계의 분류
- 존재 관계: 엔티티가 다른 엔티티에 속하는 관계
- 행위 관계: '행위'를 통해서 발생하는 관계

### 3. JOIN
    - JOIN 연산이란 식별자를 상속하고, 상속된 속성을 매핑키로 활용하여 데이터를 결합하는 것

### 4. 관계형 데이터 모델
- 자기 자신끼리의 관계
- 하나의 엔티티 내에서 인스턴스끼리 계층 구조를 가지는 경우
- 계층 구조를 갖는 인스턴스끼리 연결하는 조인을 셀프 조인이라고 한다.
- 만일 어떤 직원의 상사의 이름을 알고 싶다면 셀프 조인을 해야 한다.

### 5. 상호 배타적 관계
- 하나의 부모가 2개의 자식 엔티티를 가질 때, 행위 조건에 따라 두 자식 중 하나만 부모와 관계를 가질 수 있는 관계

# 3절 모델이 표현하는 트랜잭션의 이해
### 1. 트랜잭션: 업무 처리를 위한 논리적인 작업 단위
- 하나의 연속적인 업무 단위
- 트랜잭션에 의한 관계는 필수적인 관계 형태를 가진다.
- 하나의 트랜잭션에 속한 동작들은 모두 성공하거나, 모두 취소되어야 한다.
- 서로 독립적으로 업무가 발생해서는 안된다.

### 2. 트랜잭션의 특징
- A(Atomicity) 원자성: 트랜잭션은 더 이상 분해가 불가능한 업무의 최소 단위이므로 전부 처리되거나 모두 처리되지 않아야한다.
- C(Consistency) 일관성: 일관된 상태의 db에서 하나의 트랜잭션을 성공하고 완료하고 나면 그 DB는 여전히 일관된 상태여야한다.
- I(Isolation) 격리성: 실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다. 
- D(Durability) 영속성: 트랜잭션이 성공적으로 완료되었다면 데이터베이스에 영속적으로 저장된다.

# 4절 NULL 속성의 이해
### 1. NULL의 특징
- 아직 정의 되지 않은 값, 0이 아니고, 공백도 아님
- NULL값을 포함하는 연산의 경우 결과도 NULL 값이다.
- NULL은 집계함수에서 무시됨.
- NULL은 IS NULL을 제외하고 unknown을 반환한다.

# 5절 본질 식별자 vs 인조 식별자
### 본질(업무 식별자)
업무에 의해 만들어지는 식별자

### 인조 식별자
업무에 존재하지는 않으나 원래의 식별자가 너무 복잡하게 구성되어 있어 인위적으로 만든 식별자
- 원조 식별자가 PK 2개 이상인 복합 식별자 일때 속성들을 하나의 속성으로 묶어서 사용하면 이것이 인조식별자 
- 일련번호의 상태

### 인조 식별자의 장/단점
- 장점
    - 추가적인 연산 없이 주 식별자를 생성하기 떄문에 개발 편의성 향상
- 단점
    - 중복 데이터 발생 가능성 -> 데이터 품질 저하
    - 불필요한 인덱스 생성
    - 별도의 인덱스 생성이 필요